<template>
	<div class="game-area">
		<div class="game">
			<div class="game-background"></div>
			<!-- Visual Novel Display -->
			<div class="visual-novel-display">
				<!-- Character sprite display -->
				<div class="character-display">
					<img 
						v-if="currentCharacterImage" 
						:src="currentCharacterImage" 
						:alt="currentCharacterName"
						class="character-sprite"
					/>
				</div>
			</div>
		</div>
		<div class="game-ui">
			<!-- Dialog triggers in game-ui -->
			 <div v-if="g.mc.name">
				Игра началась, {{ g.mc.name }}!
			</div>
			<div v-else>
				Игра началась
			</div>
			<div class="dialog-triggers">
				<button @click="startFirstDialog" class="dialog-trigger-button">
					Начать первый диалог
				</button>
				<button @click="startSecondDialog" class="dialog-trigger-button">
					Начать второй диалог
				</button>
				<button @click="startThirdDialog" class="dialog-trigger-button">
					Начать третий диалог
				</button>
				<button @click="startTestDialog" class="dialog-trigger-button">
					Тест переменных
				</button>
			</div>
			
			<!-- Main dialog display in game-ui -->
			<div v-if="dialogStore.isDialogActive" class="dialog-display">
				<div class="dialog-speaker">
					{{ getCurrentSpeakerName }}
				</div>
				<div class="dialog-text">
					{{ getCurrentDialogText }}
				</div>
				<!-- Next button for sequential phrases -->
				<div class="dialog-controls">
					<button 
						v-if="!hasChoices && dialogStore.isDialogActive" 
						@click="nextDialogPhrase" 
						class="dialog-next-button"
					>
						{{ t('next') }}
					</button>
				</div>
			</div>
			
			<!-- Dialog choices modal in center of screen without backdrop -->
			<div v-if="showDialogChoices && dialogStore.getCurrentNode?.choices?.length > 0" 
				 class="dialog-choices-modal">
				<div class="modal-container">
					<div class="dialog-choices-content">
						<button 
							v-for="choice in getCurrentChoices" 
							:key="choice.id"
							class="dialog-choice-button"
							@click="selectChoice(choice.id)"
						>
							{{ choice.displayText }}
						</button>
					</div>
				</div>
			</div>
		</div>
		<div class="game-modals">
			<!-- Main menu modal with dynamic content -->
			<div v-if="showMainMenu" class="main-menu-modal" @keydown.esc="toggleMainMenu">
				<div class="page-area __dark">
					<div class="content-area">
						<DynamicContentArea 
							:current-view="currentView" 
							@back-to-menu="showHomeContent"
							@settings-saved="onSettingsSaved"
							@settings-reset="onSettingsReset"
						/>
					</div>
					<div class="menu-area __static">
						<MainMenu :in-game-context="true" :on-continue="toggleMainMenu" show-back-to-main @navigate="handleNavigation" />
					</div>
				</div>
			</div>
		</div>
	</div>
</template>

<script setup>
	import { ref, computed, onMounted, onUnmounted, watch } from 'vue'
	import { useI18n } from 'vue-i18n'
	import { useGameStore } from '@/stores/game'
	import { useDialogStore } from '@/stores/dialog'
	import { useRouter } from 'vue-router'
	import { getCharacterByIdAsync, getCharacterImagePath } from '@/utils/characterLoader.js'
	import { resolveImagePath } from '@/utils/imageLoader.js'
	import MainMenu from '@/components/MainMenu.vue'
	import DynamicContentArea from '@/components/DynamicContentArea.vue'
	
	const { locale, t } = useI18n()
	const g = useGameStore()
	const dialogStore = useDialogStore()
	const router = useRouter()
	const showMainMenu = ref(false)
	const showDialogChoices = ref(false)
	const currentView = ref('main-menu')
	const characterDataCache = ref({})
	
	// Current speaker character image for visual novel display
	const currentCharacterImage = computed(() => {
		const speaker = dialogStore.getCurrentNode?.speaker
		if (!speaker || speaker === 'mc') return null
		
		// Get image for NPC
		const imagePath = getCharacterImagePath(speaker)
		if (imagePath) {
			return resolveImagePath(imagePath)
		}
		return null
	})
	
	// Current character name
	const currentCharacterName = computed(() => {
		const speaker = dialogStore.getCurrentNode?.speaker
		if (!speaker) return ''
		
		if (speaker === 'mc') {
			return g.mc.name || 'MC'
		}
		
		if (g.characters && g.characters[speaker]) {
			return g.characters[speaker].title || g.characters[speaker].name || speaker
		}
		
		return speaker
	})
	
	// Toggle main menu visibility
	const toggleMainMenu = () => {
		showMainMenu.value = !showMainMenu.value
		// Reset to main menu view when opening/closing
		if (showMainMenu.value) {
			currentView.value = 'main-menu'
		}
	}
	
	// Navigation handlers
	const showHomeContent = () => {
		currentView.value = 'main-menu'
		showMainMenu.value = false
	}
	
	const showSettings = () => {
		currentView.value = 'settings'
	}
	
	const showSaves = () => {
		currentView.value = 'saves'
	}
	
	// Navigate to home/main menu page
	const navigateToHome = () => {
		router.push('/home')
	}
	
	const handleNavigation = (view) => {
		if (view === 'settings') {
			showSettings()
		} else if (view === 'saves') {
			showSaves()
		} else if (view === 'main-menu') {
			// Navigate to home page when "На главную" is clicked
			navigateToHome()
		} else {
			showHomeContent()
		}
	}
	
	function onSettingsSaved() {
		console.log('Settings saved')
	}
	
	function onSettingsReset() {
		console.log('Settings reset to default')
	}
	
	// Handle ESC key press
	const handleKeyDown = (event) => {
		if (event.key === 'Escape') {
			// Always open the main menu when ESC is pressed, regardless of dialog state
			toggleMainMenu()
		}
	}
	
	// Start the first intro dialog
	const startFirstDialog = () => {
		dialogStore.startDialog('intro_scene')
		showDialogChoices.value = true
	}
	
	// Start the second dialog
	const startSecondDialog = () => {
		dialogStore.startDialog('second_scene')
		showDialogChoices.value = true
	}
	
	// Start the third dialog (sequential phrases without choices)
	const startThirdDialog = () => {
		dialogStore.startDialog('third_scene')
		showDialogChoices.value = false // No choices for this dialog
	}
	
	// Start the test variables dialog
	const startTestDialog = () => {
		dialogStore.startDialog('test_variables')
		showDialogChoices.value = true
	}
	
	// Handle choice selection
	const selectChoice = (choiceId) => {
		dialogStore.makeChoice(choiceId)
		// After making a choice, show choices again if there are any
		// If dialog ended, hide the choices modal
		if (!dialogStore.isDialogActive) {
			showDialogChoices.value = false
		} else if (dialogStore.getCurrentNode?.choices?.length > 0) {
			showDialogChoices.value = true
		} else {
			// No choices available, hide the modal
			showDialogChoices.value = false
		}
	}
	
	// Next dialog phrase for sequential dialogs
	const nextDialogPhrase = () => {
		dialogStore.nextSequentialNode()
		// If dialog ended, hide the dialog
		if (!dialogStore.isDialogActive) {
			showDialogChoices.value = false
		}
	}
	
	// Check if current node has choices
	const hasChoices = computed(() => {
		return dialogStore.getCurrentNode?.choices?.length > 0
	})
	
	// Get current speaker name based on speaker ID
	const getCurrentSpeakerName = computed(() => {
		const speaker = dialogStore.getCurrentNode?.speaker
		if (!speaker) return ''
		
		// Use player name from store for MC
		if (speaker === 'mc') {
			// Try to get translated name first, fallback to store value
			const translatedName = t(`characters.${speaker}.name`)
			if (translatedName && !translatedName.includes('characters.')) {
				return translatedName
			}
			return g.mc.name || 'MC'
		}
		
		// Use character name from translations for NPCs
		if (g.characters && g.characters[speaker]) {
			// Try to get translated name first, fallback to store value
			const translatedTitle = t(`characters.${speaker}.title`)
			if (translatedTitle && !translatedTitle.includes('characters.')) {
				return translatedTitle
			}
			return g.characters[speaker].title || g.characters[speaker].name || speaker
		}
		
		// Fallback
		return speaker
	})
	
	// Get current dialog text based on current locale
	const getCurrentDialogText = computed(() => {
		const node = dialogStore.getCurrentNode
		if (!node) return ''
		
		// Get the text directly (no need to handle multiple languages here anymore)
		let text = node.text || ''
		
		// Process text with flexible variable replacement
		text = processDialogText(text)
		
		return text
	})
	
	// Get current choices with processed text
	const getCurrentChoices = computed(() => {
		const node = dialogStore.getCurrentNode
		if (!node || !node.choices) return []
		
		return node.choices.map(choice => {
			// Get the text directly (no need to handle multiple languages here anymore)
			let text = choice.text || ''
			
			// Process text with flexible variable replacement
			text = processDialogText(text)
			
			return {
				...choice,
				displayText: text
			}
		})
	})
	
	// Flexible text processing function that can replace any variable from game store
	const processDialogText = (text) => {
		if (!text) return ''
		
		// Create a regex to match placeholders like {mc.name} or {world.cur_time} (without 'g.')
		// Also support the old format with 'g.' for backward compatibility
		const placeholderRegex = /{(?:g\.)?[\w.]+}/g
		
		return text.replace(placeholderRegex, (match) => {
			// Remove the curly braces
			const content = match.slice(1, -1) // Remove '{' and '}'
			
			// Remove 'g.' prefix if present (for backward compatibility)
			const path = content.startsWith('g.') ? content.slice(2) : content
			
			// Special handling for character names - try to get translated values first
			if (path.startsWith('characters.')) {
				// Try to get translated value first
				const pathParts = path.split('.')
				if (pathParts.length >= 3) {
					const characterId = pathParts[1]
					const property = pathParts[2]
					const translatedValue = t(`characters.${characterId}.${property}`)
					if (translatedValue && !translatedValue.includes('characters.')) {
						return translatedValue
					}
				}
			}
			
			// Navigate through the game store object using the path
			try {
				const keys = path.split('.')
				let value = g
				
				// Traverse the object using the keys
				for (const key of keys) {
					if (value && typeof value === 'object' && key in value) {
						value = value[key]
					} else {
						// If path doesn't exist, return the original placeholder
						return match
					}
				}
				
				// Return the found value or the original placeholder if value is undefined
				return value !== undefined ? String(value) : match
			} catch (error) {
				console.warn(`Error processing placeholder ${match}:`, error)
				return match // Return original placeholder if there's an error
			}
		})
	}
	
	// Add event listener when component mounts
	onMounted(() => {
		document.addEventListener('keydown', handleKeyDown)
	})
	
	// Remove event listener when component unmounts
	onUnmounted(() => {
		document.removeEventListener('keydown', handleKeyDown)
	})
	
	// Expose toggle function to be called from other components if needed
	defineExpose({
		toggleMainMenu
	})
</script>

<style>
.game-background {
	background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
}

.visual-novel-display {
	display: flex;
	align-items: flex-end;
	justify-content: center;
	width: 100%;
	height: 100%;
	padding: 20px;
}

.character-display {
	position: relative;
	display: flex;
	align-items: flex-end;
	justify-content: center;
	width: 100%;
	height: 100%;
}

.character-sprite {
	max-height: 80%;
	max-width: 60%;
	object-fit: contain;
	filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3));
}

.main-menu-modal {
	position: fixed;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	z-index: 1000;
	display: flex;
	justify-content: center;
	align-items: center;
}

.dialog-choices-modal {
	position: fixed;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	z-index: 1500;
	display: flex;
	justify-content: center;
	align-items: center;
	pointer-events: none; /* Allow clicking through the overlay */
}

.dialog-display {
	position: absolute;
	bottom: 0;
}

.dialog-choices-content {
	pointer-events: auto;
}

.modal-container {
	position: relative;
	width: 100%;
	height: 100%;
	display: flex;
	flex-direction: column;
	align-items: center;
	justify-content: center;
}

.mainmenu {
	width: 100%;
	max-width: 500px;
	background-color: transparent;
	position: relative;
}

.nav {
	position: relative;
}

.dialog-triggers {
	position: absolute;
	top: 20px;
	left: 50%;
	transform: translateX(-50%);
	display: flex;
	gap: 10px;
	z-index: 100;
}

.character-cards-btn {
	position: absolute;
	top: 20px;
	right: 20px;
	z-index: 100;
	padding: 8px 16px;
	background-color: #4a4a4a;
	color: white;
	border: 1px solid #ccc;
	border-radius: 4px;
	cursor: pointer;
}

.character-cards-btn:hover {
	background-color: #5a5a5a;
}

.main-menu-modal {
	position: fixed;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	z-index: 1000;
	display: flex;
	justify-content: center;
	align-items: center;
}
</style>